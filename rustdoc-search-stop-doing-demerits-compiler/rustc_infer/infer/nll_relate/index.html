<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="This code is kind of an alternate way of doing subtyping, supertyping, and type equating, distinct from the `combine.rs` code but very similar in its effect and design. Eventually the two ought to be merged. This code is intended for use in NLL and chalk."><meta name="keywords" content="rust, rustlang, rust-lang, nll_relate"><title>rustc_infer::infer::nll_relate - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceSerif4-Regular-1f7d512b176f0f72.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceSerif4-Bold-124a1ca42af929b6.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../../static.files/rustdoc-0136d89ac73d270a.css" id="mainThemeStyle"><link rel="stylesheet" id="themeStyle" href="../../../static.files/light-8fe2cf7ee64a76fb.css"><link rel="stylesheet" disabled href="../../../static.files/dark-7aacebe982779e9a.css"><link rel="stylesheet" disabled href="../../../static.files/ayu-29dcc614f7a7b461.css"><script id="default-settings" ></script><script src="../../../static.files/storage-d43fa987303ecbbb.js"></script><script defer src="../../../static.files/main-a211dbb005fb8161.js"></script><noscript><link rel="stylesheet" href="../../../static.files/noscript-13285aec31fa243e.css"></noscript><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="sidebar-logo" href="../../../rustc_infer/index.html"><div class="logo-container"><img class="rust-logo" src="../../../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></div></a><h2></h2></nav><nav class="sidebar"><a class="sidebar-logo" href="../../../rustc_infer/index.html"><div class="logo-container"><img class="rust-logo" src="../../../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></div></a><h2 class="location"><a href="#">Module nll_relate</a></h2><div class="sidebar-elems"><section><ul class="block"><li><a href="#structs">Structs</a></li><li><a href="#enums">Enums</a></li><li><a href="#traits">Traits</a></li></ul></section></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press â€˜Sâ€™ to search, â€˜?â€™ for more optionsâ€¦" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../../../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../../static.files/wheel-5ec35bf9ca753509.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1 class="fqn">Module <a href="../../index.html">rustc_infer</a>::<wbr><a href="../index.html">infer</a>::<wbr><a class="mod" href="#">nll_relate</a><button id="copy-path" onclick="copy_path(this)" title="Copy item path to clipboard"><img src="../../../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="srclink" href="../../../src/rustc_infer/infer/nll_relate/mod.rs.html#1-1120">source</a> Â· <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="rustdoc-toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>This code is kind of an alternate way of doing subtyping,
supertyping, and type equating, distinct from the <code>combine.rs</code>
code but very similar in its effect and design. Eventually the two
ought to be merged. This code is intended for use in NLL and chalk.</p>
<p>Here are the key differences:</p>
<ul>
<li>This code may choose to bypass some checks (e.g., the occurs check)
in the case where we know that there are no unbound type inference
variables. This is the case for NLL, because at NLL time types are fully
inferred up-to regions.</li>
<li>This code uses â€œuniversesâ€ to handle higher-ranked regions and
not the leak-check. This is â€œmore correctâ€ than what rustc does
and we are generally migrating in this direction, but NLL had to
get there first.</li>
</ul>
<p>Also, this code assumes that there are no bound types at all, not even
free ones. This is ok because:</p>
<ul>
<li>we are not relating anything quantified over some type variable</li>
<li>we will have instantiated all the bound type vars already (the one
thing we relate in chalk are basically domain goals and their
constituents)</li>
</ul>
</div></details><h2 id="structs" class="small-section-header"><a href="#structs">Structs</a></h2><div class="item-table"><div class="item-row"><div class="item-left unstable module-item"><a class="struct" href="struct.BoundRegionScope.html" title="rustc_infer::infer::nll_relate::BoundRegionScope struct">BoundRegionScope</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </div></div><div class="item-row"><div class="item-left unstable module-item"><a class="struct" href="struct.ScopeInstantiator.html" title="rustc_infer::infer::nll_relate::ScopeInstantiator struct">ScopeInstantiator</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </div><div class="item-right docblock-short">When we encounter a binder like <code>for&lt;..&gt; fn(..)</code>, we actually have
to walk the <code>fn</code> value to find all the values bound by the <code>for</code>
(these are not explicitly present in the ty representation right
now). This visitor handles that: it descends the type, tracking
binder depth, and finds late-bound regions targeting the
<code>for&lt;..</code>&gt;.  For each of those, it creates an entry in
<code>bound_region_scope</code>.</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="struct" href="struct.TypeGeneralizer.html" title="rustc_infer::infer::nll_relate::TypeGeneralizer struct">TypeGeneralizer</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </div><div class="item-right docblock-short">The â€œtype generalizerâ€ is used when handling inference variables.</div></div><div class="item-row"><div class="item-left unstable module-item"><a class="struct" href="struct.TypeRelating.html" title="rustc_infer::infer::nll_relate::TypeRelating struct">TypeRelating</a></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="struct" href="struct.UniversallyQuantified.html" title="rustc_infer::infer::nll_relate::UniversallyQuantified struct">UniversallyQuantified</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </div></div></div><h2 id="enums" class="small-section-header"><a href="#enums">Enums</a></h2><div class="item-table"><div class="item-row"><div class="item-left unstable module-item"><a class="enum" href="enum.NormalizationStrategy.html" title="rustc_infer::infer::nll_relate::NormalizationStrategy enum">NormalizationStrategy</a></div></div></div><h2 id="traits" class="small-section-header"><a href="#traits">Traits</a></h2><div class="item-table"><div class="item-row"><div class="item-left unstable module-item"><a class="trait" href="trait.TypeRelatingDelegate.html" title="rustc_infer::infer::nll_relate::TypeRelatingDelegate trait">TypeRelatingDelegate</a></div></div><div class="item-row"><div class="item-left unstable module-item"><a class="trait" href="trait.VidValuePair.html" title="rustc_infer::infer::nll_relate::VidValuePair trait">VidValuePair</a><span title="Restricted Visibility">&nbsp;ğŸ”’</span> </div><div class="item-right docblock-short">When we instantiate an inference variable with a value in
<code>relate_ty_var</code>, we always have the pair of a <code>TyVid</code> and a <code>Ty</code>,
but the ordering may vary (depending on whether the inference
variable was found on the <code>a</code> or <code>b</code> sides). Therefore, this trait
allows us to factor out common code, while preserving the order
when needed.</div></div></div></section></div></main><div id="rustdoc-vars" data-root-path="../../../" data-static-root-path="../../../static.files/" data-current-crate="rustc_infer" data-themes="" data-resource-suffix="" data-rustdoc-version="1.68.0-dev" data-search-js="search-2dc3ecf90030732f.js" data-settings-js="settings-bebeae96e00e4617.js" data-settings-css="settings-af96d9e2fc13e081.css" ></div></body></html>