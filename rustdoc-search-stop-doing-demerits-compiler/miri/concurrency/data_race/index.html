<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Implementation of a data-race detector using Lamport Timestamps / Vector-clocks based on the Dynamic Race Detection for C++: https://www.doc.ic.ac.uk/~afd/homepages/papers/pdfs/2017/POPL.pdf which does not report false-positives when fences are used, and gives better accuracy in presence of read-modify-write operations."><meta name="keywords" content="rust, rustlang, rust-lang, data_race"><title>miri::concurrency::data_race - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceSerif4-Regular-1f7d512b176f0f72.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceSerif4-Bold-124a1ca42af929b6.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../../static.files/rustdoc-0136d89ac73d270a.css" id="mainThemeStyle"><link rel="stylesheet" id="themeStyle" href="../../../static.files/light-8fe2cf7ee64a76fb.css"><link rel="stylesheet" disabled href="../../../static.files/dark-7aacebe982779e9a.css"><link rel="stylesheet" disabled href="../../../static.files/ayu-29dcc614f7a7b461.css"><script id="default-settings" ></script><script src="../../../static.files/storage-d43fa987303ecbbb.js"></script><script defer src="../../../static.files/main-a211dbb005fb8161.js"></script><noscript><link rel="stylesheet" href="../../../static.files/noscript-13285aec31fa243e.css"></noscript><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="sidebar-logo" href="../../../miri/index.html"><div class="logo-container"><img class="rust-logo" src="../../../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></div></a><h2></h2></nav><nav class="sidebar"><a class="sidebar-logo" href="../../../miri/index.html"><div class="logo-container"><img class="rust-logo" src="../../../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></div></a><h2 class="location"><a href="#">Module data_race</a></h2><div class="sidebar-elems"><section><ul class="block"><li><a href="#structs">Structs</a></li><li><a href="#enums">Enums</a></li><li><a href="#traits">Traits</a></li><li><a href="#types">Type Definitions</a></li></ul></section></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press â€˜Sâ€™ to search, â€˜?â€™ for more optionsâ€¦" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../../../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../../static.files/wheel-5ec35bf9ca753509.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1 class="fqn">Module <a href="../../index.html">miri</a>::<wbr><a href="../index.html">concurrency</a>::<wbr><a class="mod" href="#">data_race</a><button id="copy-path" onclick="copy_path(this)" title="Copy item path to clipboard"><img src="../../../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="srclink" href="../../../src/miri/concurrency/data_race.rs.html#1-1582">source</a> Â· <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="rustdoc-toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Implementation of a data-race detector using Lamport Timestamps / Vector-clocks
based on the Dynamic Race Detection for C++:
<a href="https://www.doc.ic.ac.uk/~afd/homepages/papers/pdfs/2017/POPL.pdf">https://www.doc.ic.ac.uk/~afd/homepages/papers/pdfs/2017/POPL.pdf</a>
which does not report false-positives when fences are used, and gives better
accuracy in presence of read-modify-write operations.</p>
<p>The implementation contains modifications to correctly model the changes to the memory model in C++20
regarding the weakening of release sequences: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0982r1.html">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0982r1.html</a>.
Relaxed stores now unconditionally block all currently active release sequences and so per-thread tracking of release
sequences is not needed.</p>
<p>The implementation also models races with memory allocation and deallocation via treating allocation and
deallocation as a type of write internally for detecting data-races.</p>
<p>Weak memory orders are explored but not all weak behaviours are exhibited, so it can still miss data-races
but should not report false-positives</p>
<p>Data-race definition from(<a href="https://en.cppreference.com/w/cpp/language/memory_model#Threads_and_data_races">https://en.cppreference.com/w/cpp/language/memory_model#Threads_and_data_races</a>):
a data race occurs between two memory accesses if they are on different threads, at least one operation
is non-atomic, at least one operation is a write and neither access happens-before the other. Read the link
for full definition.</p>
<p>This re-uses vector indexes for threads that are known to be unable to report data-races, this is valid
because it only re-uses vector indexes once all currently-active (not-terminated) threads have an internal
vector clock that happens-after the join operation of the candidate thread. Threads that have not been joined
on are not considered. Since the threadâ€™s vector clock will only increase and a data-race implies that
there is some index x where <code>clock[x] &gt; thread_clock</code>, when this is true <code>clock[candidate-idx] &gt; thread_clock</code>
can never hold and hence a data-race can never be reported in that vector index again.
This means that the thread-index can be safely re-used, starting on the next timestamp for the newly created
thread.</p>
<p>The timestamps used in the data-race detector assign each sequence of non-atomic operations
followed by a single atomic or concurrent operation a single timestamp.
Write, Read, Write, ThreadJoin will be represented by a single timestamp value on a thread.
This is because extra increment operations between the operations in the sequence are not
required for accurate reporting of data-race values.</p>
<p>As per the paper a threads timestamp is only incremented after a release operation is performed
so some atomic operations that only perform acquires do not increment the timestamp. Due to shared
code some atomic operations may increment the timestamp when not necessary but this has no effect
on the data-race detection code.</p>
</div></details><h2 id="structs" class="small-section-header"><a href="#structs">Structs</a></h2><div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.AtomicMemoryCellClocks.html" title="miri::concurrency::data_race::AtomicMemoryCellClocks struct">AtomicMemoryCellClocks</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </div><div class="item-right docblock-short">Externally stored memory cell clocks
explicitly to reduce memory usage for the
common case where no atomic operations
exists on the memory cell.</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.DataRace.html" title="miri::concurrency::data_race::DataRace struct">DataRace</a></div><div class="item-right docblock-short">Error returned by finding a data race
should be elaborated upon.</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.GlobalState.html" title="miri::concurrency::data_race::GlobalState struct">GlobalState</a></div><div class="item-right docblock-short">Global data-race detection state, contains the currently
executing thread as well as the vector-clocks associated
with each of the threads.</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.MemoryCellClocks.html" title="miri::concurrency::data_race::MemoryCellClocks struct">MemoryCellClocks</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </div><div class="item-right docblock-short">Memory Cell vector clock metadata
for data-race detection.</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.ThreadClockSet.html" title="miri::concurrency::data_race::ThreadClockSet struct">ThreadClockSet</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </div><div class="item-right docblock-short">The current set of vector clocks describing the state
of a thread, contains the happens-before clock and
additional metadata to model atomic fence operations.</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.ThreadExtraState.html" title="miri::concurrency::data_race::ThreadExtraState struct">ThreadExtraState</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </div><div class="item-right docblock-short">Extra metadata associated with a thread.</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.VClockAlloc.html" title="miri::concurrency::data_race::VClockAlloc struct">VClockAlloc</a></div><div class="item-right docblock-short">Vector clock metadata for a logical memory allocation.</div></div></div><h2 id="enums" class="small-section-header"><a href="#enums">Enums</a></h2><div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="enum" href="enum.AtomicFenceOrd.html" title="miri::concurrency::data_race::AtomicFenceOrd enum">AtomicFenceOrd</a></div><div class="item-right docblock-short">Valid atomic fence orderings, subset of atomic::Ordering.</div></div><div class="item-row"><div class="item-left module-item"><a class="enum" href="enum.AtomicReadOrd.html" title="miri::concurrency::data_race::AtomicReadOrd enum">AtomicReadOrd</a></div><div class="item-right docblock-short">Valid atomic read orderings, subset of atomic::Ordering.</div></div><div class="item-row"><div class="item-left module-item"><a class="enum" href="enum.AtomicRwOrd.html" title="miri::concurrency::data_race::AtomicRwOrd enum">AtomicRwOrd</a></div><div class="item-right docblock-short">Valid atomic read-write orderings, alias of atomic::Ordering (not non-exhaustive).</div></div><div class="item-row"><div class="item-left module-item"><a class="enum" href="enum.AtomicWriteOrd.html" title="miri::concurrency::data_race::AtomicWriteOrd enum">AtomicWriteOrd</a></div><div class="item-right docblock-short">Valid atomic write orderings, subset of atomic::Ordering.</div></div><div class="item-row"><div class="item-left module-item"><a class="enum" href="enum.WriteType.html" title="miri::concurrency::data_race::WriteType enum">WriteType</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </div><div class="item-right docblock-short">Type of write operation: allocating memory
non-atomic writes and deallocating memory
are all treated as writes for the purpose
of the data-race detector.</div></div></div><h2 id="traits" class="small-section-header"><a href="#traits">Traits</a></h2><div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="trait" href="trait.EvalContextExt.html" title="miri::concurrency::data_race::EvalContextExt trait">EvalContextExt</a></div></div><div class="item-row"><div class="item-left module-item"><a class="trait" href="trait.EvalContextPrivExt.html" title="miri::concurrency::data_race::EvalContextPrivExt trait">EvalContextPrivExt</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </div></div></div><h2 id="types" class="small-section-header"><a href="#types">Type Definitions</a></h2><div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="type" href="type.AllocState.html" title="miri::concurrency::data_race::AllocState type">AllocState</a></div></div></div></section></div></main><div id="rustdoc-vars" data-root-path="../../../" data-static-root-path="../../../static.files/" data-current-crate="miri" data-themes="" data-resource-suffix="" data-rustdoc-version="1.68.0-dev" data-search-js="search-2dc3ecf90030732f.js" data-settings-js="settings-bebeae96e00e4617.js" data-settings-css="settings-af96d9e2fc13e081.css" ></div></body></html>