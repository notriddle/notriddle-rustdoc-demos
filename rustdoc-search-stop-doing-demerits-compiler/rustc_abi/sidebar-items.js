window.SIDEBAR_ITEMS = {"enum":[["Abi","Describes how values of the type are passed by target ABIs, in terms of categories of C types there are ABI rules for."],["Endian","Endianness of the target, which must match cfg(target-endian)."],["FieldsShape","Describes how the fields of a type are located in memory."],["InitKind","Used in `might_permit_raw_init` to indicate the kind of initialisation that is checked to be valid"],["Integer","Integers, also used for enum discriminants."],["IntegerType",""],["PointerKind",""],["Primitive","Fundamental unit of memory access and layout."],["Scalar","Information about one scalar component of a Rust type."],["StructKind",""],["TagEncoding",""],["TargetDataLayoutErrors",""],["Variants",""]],"mod":[["layout",""]],"struct":[["AbiAndPrefAlign","A pair of alignments, ABI-mandated and preferred."],["AddressSpace","An identifier that specifies the address space that some operation should operate on. Special address spaces have an effect on code generation, depending on the target and the address spaces it implements."],["Align","Alignment of a type in bytes (always a power of two)."],["LayoutS",""],["Niche",""],["PointeeInfo",""],["ReprFlags",""],["ReprOptions","Represents the repr options provided by the user,"],["Size","Size of a type in bytes."],["TargetDataLayout","Parsed Data layout for a target, which contains everything needed to compute layouts."],["WrappingRange","Inclusive wrap-around range of valid values, that is, if start > end, it represents `start..=MAX`, followed by `0..=end`."]],"trait":[["HasDataLayout",""],["HashStableContext","Requirements for a `StableHashingContext` to be used in this crate. This is a hack to allow using the `HashStable_Generic` derive macro instead of implementing everything in `rustc_middle`."],["LayoutCalculator",""]]};